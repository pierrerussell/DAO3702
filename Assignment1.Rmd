---
title: "DBA3702 Assignment 1"
author: "
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
geometry: margin=1in
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 6, fig.align = "center")
```

\newpage

# Part 1: Data Wrangling with dplyr (45 points)

## Question 1.1: Data Exploration (5 points)

### a) Load packages and read data

```{r q1.1a}
library(dplyr)
library(tibble)

employees <- read.csv("data/employees.csv")
```

### b) Convert to tibble and display first 10 rows

```{r q1.1b}
employees <- as_tibble(employees)
print(employees, n = 10)
```

### c) Data summary

```{r q1.1c}
cat("Rows:", nrow(employees), "\n")
cat("Columns:", ncol(employees), "\n")

sapply(employees, typeof)
summary(employees)
```

We have 50 employees with 8 variables. The data includes basic info like name and department, plus numeric stuff like salary, years of experience, performance scores, and project counts. Performance ranges from around 2.9 to 4.9, and experience goes from 1 to 16 years.

\newpage

## Question 1.2: Selecting and Filtering (8 points)

### d) Select specific columns

```{r q1.2d}
employees %>%
  select(name, department, role, performance_score)
```

### e) Filter performance > 4.0

```{r q1.2e}
high_performers <- employees %>%
  filter(performance_score > 4.0)
high_performers
cat("Count:", nrow(high_performers))
```

### f) Engineering/Marketing with > 5 years experience

```{r q1.2f}
employees %>%
  filter((department == "Engineering" | department == "Marketing") & years_exp > 5)
```

### g) Select using helpers

```{r q1.2g}
employees %>%
  select(contains("score") | starts_with("p"))
```

This grabs performance_score and projects_completed - the columns with "score" in the name or starting with "p".

\newpage

## Question 1.3: Sorting and Ranking (7 points)

### h) Top 5 highest-paid

```{r q1.3h}
employees %>%
  arrange(desc(salary)) %>%
  head(5)
```

### i) Sort by department then performance

```{r q1.3i}
employees %>%
  arrange(department, desc(performance_score))
```

### j) Lowest salary in each department

```{r q1.3j}
employees %>%
  arrange(department, salary) %>%
  group_by(department) %>%
  slice_head(n = 1) %>%
  ungroup()
```

\newpage

## Question 1.4: Creating New Variables (10 points)

### k) Salary per year of experience

```{r q1.4k}
employees %>%
  mutate(salary_per_year_exp = salary / years_exp) %>%
  select(name, salary, years_exp, salary_per_year_exp)
```

### l) Performance category

```{r q1.4l}
employees_cat <- employees %>%
  mutate(performance_category = case_when(
    performance_score >= 4.5 ~ "Outstanding",
    performance_score >= 3.5 ~ "Exceeds Expectations",
    performance_score >= 2.5 ~ "Meets Expectations",
    TRUE ~ "Needs Improvement"
  ))

employees_cat %>%
  select(name, performance_score, performance_category)

employees_cat %>% count(performance_category)
```

### m) Experience level

```{r q1.4m}
employees_exp <- employees %>%
  mutate(experience_level = case_when(
    years_exp <= 3 ~ "Entry",
    years_exp <= 7 ~ "Mid",
    years_exp <= 12 ~ "Senior",
    TRUE ~ "Expert"
  ))

employees_exp %>%
  select(name, years_exp, experience_level)

employees_exp %>% count(experience_level)
```

### n) High performer flag

```{r q1.4n}
employees %>%
  mutate(is_high_performer = performance_score > 4.0 & projects_completed >= 10) %>%
  filter(is_high_performer) %>%
  select(name, department, performance_score, projects_completed)
```

\newpage

## Question 1.5: Aggregation and Grouping (15 points)

### o) Company-wide summary

```{r q1.5o}
employees %>%
  summarise(
    total_employees = n(),
    avg_salary = mean(salary),
    avg_performance = mean(performance_score),
    total_projects = sum(projects_completed)
  )
```

### p) Summary by department

```{r q1.5p}
employees %>%
  group_by(department) %>%
  summarise(
    count = n(),
    avg_salary = mean(salary),
    avg_perf = mean(performance_score),
    min_exp = min(years_exp),
    max_exp = max(years_exp)
  )
```

### q) Summary by department and role

```{r q1.5q}
dept_role <- employees %>%
  group_by(department, role) %>%
  summarise(avg_salary = mean(salary), count = n(), .groups = "drop") %>%
  arrange(desc(avg_salary))

dept_role

# Highest combo:
dept_role %>% head(1)
```

The highest average salary is in the department-role combo shown above.

### r) Salary as % of department average

```{r q1.5r}
employees %>%
  group_by(department) %>%
  mutate(
    dept_avg = mean(salary),
    pct_of_avg = salary / dept_avg * 100
  ) %>%
  ungroup() %>%
  arrange(desc(pct_of_avg)) %>%
  select(name, department, salary, dept_avg, pct_of_avg)
```

The person at the top earns the most relative to their department's average.

### s) Top 3 departments by performance (3+ years exp)

```{r q1.5s}
employees %>%
  filter(years_exp >= 3) %>%
  group_by(department) %>%
  summarise(avg_perf = mean(performance_score)) %>%
  arrange(desc(avg_perf)) %>%
  head(3)
```

\newpage

# Part 2: Social Network Analysis (45 points)

## Question 2.1: Network Construction and Visualization (10 points)

### t) Load network data

```{r q2.1t}
library(igraph)
library(RColorBrewer)

email_nodes <- read.csv("data/email_nodes.csv")
email_edges <- read.csv("data/email_edges.csv")

head(email_nodes)
head(email_edges)
```

### u) Construct undirected graph

```{r q2.1u}
email_graph <- graph.data.frame(email_edges, vertices = email_nodes, directed = FALSE)

cat("Nodes:", vcount(email_graph), "\n")
cat("Edges:", ecount(email_graph), "\n")
```

### v) Basic and improved plots

```{r q2.1v, fig.height=5}
par(mfrow = c(1, 2), mar = c(1, 1, 2, 1))
plot(email_graph, main = "Basic")

deg <- degree(email_graph)
plot(email_graph, vertex.label = NA, vertex.size = sqrt(deg) * 3,
     edge.width = 0.5, main = "Improved")
```

The improved version removes the messy labels and sizes nodes by how connected they are.

### w) Department-colored network

```{r q2.1w}
depts <- V(email_graph)$department
unique_depts <- unique(depts)
colors <- brewer.pal(length(unique_depts), "Set1")
names(colors) <- unique_depts

par(mfrow = c(1, 1), mar = c(1, 1, 2, 5))
plot(email_graph, vertex.label = NA, vertex.size = sqrt(deg) * 3,
     vertex.color = colors[depts], edge.width = 0.5,
     main = "By Department")
legend("topright", unique_depts, fill = colors, cex = 0.7, bty = "n")
```

\newpage

## Question 2.2: Connected Components (8 points)

### x) Find connected components

```{r q2.2x}
comp <- components(email_graph)
cat("Number of components:", comp$no, "\n")
```

### y) Largest component size

```{r q2.2y}
lcc_size <- max(comp$csize)
cat("Largest component:", lcc_size, "employees\n")
cat("That's", round(lcc_size / vcount(email_graph) * 100, 1), "% of everyone\n")
```

### z) Extract and plot largest component

```{r q2.2z}
lcc_id <- which.max(comp$csize)
lcc_nodes <- which(comp$membership == lcc_id)
lcc <- induced_subgraph(email_graph, lcc_nodes)

cat("LCC has", vcount(lcc), "nodes and", ecount(lcc), "edges\n")

deg_lcc <- degree(lcc)
depts_lcc <- V(lcc)$department

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = NA, vertex.size = sqrt(deg_lcc) * 3,
     vertex.color = colors[depts_lcc], edge.width = 0.5,
     main = "Largest Connected Component")
legend("topright", unique_depts, fill = colors, cex = 0.7, bty = "n")
```

### aa) Why use the largest connected component?

For closeness centrality, you need every node to be reachable from every other node. If the graph is disconnected, some distances become infinite and the calculation breaks. Using just the largest component avoids this problem and gives us meaningful values to work with.

\newpage

## Question 2.3: Centrality Metrics (15 points)

### bb) Degree Centrality

```{r q2.3bb}
deg_cent <- degree(lcc)
deg_df <- data.frame(id = as.integer(V(lcc)$name), degree = deg_cent) %>%
  arrange(desc(degree))

cat("Top 5 by degree:\n")
head(deg_df, 5)

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = V(lcc)$name, vertex.label.cex = 0.5,
     vertex.size = deg_cent * 1.5, vertex.color = colors[depts_lcc],
     edge.width = 0.5, main = "Sized by Degree")
legend("topright", unique_depts, fill = colors, cex = 0.6, bty = "n")
```

### cc) Closeness Centrality

```{r q2.3cc}
close_cent <- closeness(lcc, normalized = TRUE)
close_df <- data.frame(id = as.integer(V(lcc)$name), closeness = close_cent) %>%
  arrange(desc(closeness))

cat("Top 5 by closeness:\n")
head(close_df, 5)
```

High closeness means you can reach everyone else pretty quickly - you're not stuck in a corner of the network. These people are good for spreading info fast since they're "close" to everyone.

### dd) Betweenness Centrality

```{r q2.3dd}
btw_cent <- betweenness(lcc, normalized = TRUE)
btw_df <- data.frame(id = as.integer(V(lcc)$name), betweenness = btw_cent) %>%
  arrange(desc(betweenness))

cat("Top 5 by betweenness:\n")
head(btw_df, 5)
```

Betweenness measures how often someone sits on the shortest path between other people. High betweenness = you're a bridge or connector. These folks control info flow - if they don't pass something along, it might not get where it needs to go.

### ee) PageRank

```{r q2.3ee}
pr <- page_rank(lcc)$vector
pr_df <- data.frame(id = as.integer(V(lcc)$name), pagerank = pr) %>%
  arrange(desc(pagerank))

cat("Top 5 by PageRank:\n")
head(pr_df, 5)
```

PageRank is different from degree because it cares about *who* you're connected to. Being friends with popular people boosts your score more than being friends with people no one else talks to. It's about influence, not just connection count.

### ff) Comparing all metrics

```{r q2.3ff}
all_cent <- data.frame(
  id = as.integer(V(lcc)$name),
  dept = V(lcc)$department,
  role = V(lcc)$role,
  degree = deg_cent,
  closeness = close_cent,
  betweenness = btw_cent,
  pagerank = pr
)

top10 <- all_cent %>% arrange(desc(degree)) %>% head(10)
top10

# Rankings
top10 %>%
  mutate(
    deg_r = rank(-degree),
    close_r = rank(-closeness),
    btw_r = rank(-betweenness),
    pr_r = rank(-pagerank)
  ) %>%
  select(id, deg_r, close_r, btw_r, pr_r)
```

Some people rank high on everything - they're the real network stars. Others might have high betweenness but only moderate degree, meaning they're important bridges even without tons of connections. You can also see that managers/leads tend to show up more, which makes sense given their coordinating role.

\newpage

## Question 2.4: Community Detection (12 points)

### gg) Spinglass clustering

```{r q2.4gg}
set.seed(42)
comm <- cluster_spinglass(lcc)

cat("Communities found:", length(comm), "\n")
cat("Modularity:", round(modularity(comm), 3), "\n")
```

### hh) Community sizes

```{r q2.4hh}
mem <- membership(comm)
table(mem)
```

### ii) Visualize by community

```{r q2.4ii}
num_comm <- length(unique(mem))
comm_colors <- brewer.pal(max(3, num_comm), "Set2")

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = V(lcc)$name, vertex.label.cex = 0.5,
     vertex.size = 10, vertex.color = comm_colors[mem],
     edge.width = 0.5, main = "By Community")
legend("topright", paste("Comm", 1:num_comm), fill = comm_colors[1:num_comm],
       cex = 0.6, bty = "n")
```

### jj) Community vs Department

```{r q2.4jj}
comm_dept <- data.frame(
  id = as.integer(V(lcc)$name),
  community = mem,
  department = V(lcc)$department
)

xtab <- table(comm_dept$community, comm_dept$department)
xtab

cat("\nPercentages:\n")
round(prop.table(xtab, 1) * 100, 1)
```

The communities don't match up perfectly with departments. Some communities have people from multiple departments, which shows there's cross-team communication happening. That's generally a good thing - it means people aren't just stuck in their own silos.

### kk) Business insights

A few things management could take from this:

- The communities show how people actually communicate, not just how the org chart says they should
- People who bridge multiple communities are valuable - they help different groups stay connected
- If a community is 100% one department, that might be a warning sign of a silo
- When planning changes or announcements, it's smart to work with community leaders to spread the word effectively

\newpage

# Part 3: Integration and Insights (10 points)

## Question 3.1: Joining Data (5 points)

### ll) Join employee data with centrality metrics

```{r q3.1ll}
cent_df <- data.frame(
  employee_id = as.integer(V(lcc)$name),
  degree = degree(lcc),
  closeness = closeness(lcc, normalized = TRUE),
  betweenness = betweenness(lcc, normalized = TRUE),
  pagerank = page_rank(lcc)$vector
)

combined <- employees %>%
  inner_join(cent_df, by = "employee_id")

combined %>%
  select(employee_id, name, department, performance_score,
         degree, closeness, betweenness, pagerank) %>%
  head(10)
```

### mm) Correlation analysis

```{r q3.1mm}
cat("Degree vs Performance:", round(cor(combined$degree, combined$performance_score), 3), "\n")
cat("Closeness vs Performance:", round(cor(combined$closeness, combined$performance_score), 3), "\n")
cat("Betweenness vs Performance:", round(cor(combined$betweenness, combined$performance_score), 3), "\n")
cat("PageRank vs Performance:", round(cor(combined$pagerank, combined$performance_score), 3), "\n")
```

There's some relationship between network position and performance, but it's not super strong. Being well-connected might help with performance, or maybe high performers naturally end up more connected. Either way, it's not the whole story - plenty of other factors matter too.

### nn) High performers with low centrality

```{r q3.1nn}
med_deg <- median(combined$degree)
cat("Median degree:", med_deg, "\n\n")

combined %>%
  filter(performance_score > 4.0 & degree < med_deg) %>%
  select(employee_id, name, department, role, performance_score, degree, projects_completed) %>%
  arrange(desc(performance_score))
```

These are people doing great work but flying under the radar network-wise. They might be specialists who don't need to talk to everyone, or just more introverted. Management should make sure these folks aren't getting overlooked for promotions just because they're not as visible in the network.

\newpage

## Question 3.2: Executive Summary (5 points)

```{r exec-setup, echo=FALSE}
avg_perf <- round(mean(employees$performance_score), 2)
total_projects <- sum(employees$projects_completed)
high_perf_n <- nrow(employees %>% filter(performance_score > 4.0 & projects_completed >= 10))
lcc_n <- vcount(lcc)

hubs <- combined %>% arrange(desc(betweenness)) %>% head(3)
hub_names <- paste(hubs$name, collapse = ", ")
```

### Executive Summary for TechConnect Management

**Overview**

We analyzed TechConnect's employee data and email communication patterns to understand performance trends and how information flows through the organization.

**Performance Findings**

The company's average performance score is `r avg_perf` out of 5, which is pretty solid. Across all departments, employees have completed `r total_projects` projects total. We found `r high_perf_n` people who are standout performers - scoring above 4.0 and completing 10+ projects each. There's some variation between departments, but overall the workforce is performing well.

**Network Structure**

Looking at email patterns, `r lcc_n` out of 50 employees are in the main communication cluster. The network shows that people don't just talk within their own departments - there's a fair amount of cross-team communication. The communities we detected overlap with departments but aren't a perfect match, which suggests people are collaborating across org boundaries.

**Key People**

A few employees stand out as communication hubs: `r hub_names`. These folks have high betweenness centrality, meaning they connect different parts of the organization. If one of them left, it could seriously disrupt how information gets around.

**Recommendations**

1. **Use your connectors** - The people with high betweenness are natural choices for spreading important updates or leading cross-functional projects.

2. **Watch for silos** - If any department starts communicating only internally, that's worth addressing before it becomes a problem.

3. **Don't forget the quiet high performers** - Some of your best people aren't super networked. Make sure they're still getting recognized and considered for advancement.

4. **Plan for departures** - If a key bridge person leaves, have a backup plan. Maybe cross-train people or build redundant communication paths.

5. **Think about teams** - When putting together project teams, consider who already talks to whom. Natural communication patterns can make collaboration smoother.
