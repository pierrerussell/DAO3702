---
title: "DBA3702 Assignment 1"
author: "weRready"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
geometry: margin=1in
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 6, fig.align = "center")
```

\newpage

# Part 1: Data Wrangling with dplyr

## Question 1.1: Data Exploration

### a) Load packages and read data

```{r q1.1a}
library(dplyr)
library(tibble)

employees <- read.csv("data/employees.csv")
```

### b) Convert to tibble and display first 10 rows

```{r q1.1b}
employees <- as_tibble(employees)
print(employees, n = 10)
```

### c) Data summary

```{r q1.1c}
cat("Rows:", nrow(employees), "\n")
cat("Columns:", ncol(employees), "\n")

sapply(employees, typeof)
summary(employees)
```

The dataset includes information about 50 employees with 8 variables. This includes basic information, such as employee name and department, as well as quantitative information, such as salary, years of experience, performance scores, and number of projects completed.

\newpage

## Question 1.2: Selecting and Filtering

### d) Select specific columns

```{r q1.2d}
employees %>%
  select(name, department, role, performance_score)
```

### e) Select employees with performance \> 4.0

```{r q1.2e}
high_performers <- employees %>%
  filter(performance_score > 4.0)
high_performers
```

### f) Select employees in Engineering/Marketing with \> 5 years experience

```{r q1.2f}
employees %>%
  filter((department == "Engineering" | department == "Marketing") & years_exp > 5)
```

### g) Select columns using helpers

```{r q1.2g}
employees %>%
  select(contains("score") | starts_with("p"))
```

There are two columns, *performance_score* and *projects_completed*, that meet the given condition.

\newpage

## Question 1.3: Sorting and Ranking

### h) Identify top 5 highest-paid employees

```{r q1.3h}
employees %>%
  arrange(desc(salary)) %>%
  head(5)
```

### i) Sort by department, then performance

```{r q1.3i}
employees %>%
  arrange(department, desc(performance_score))
```

### j) Identify employee with lowest salary in each department

```{r q1.3j}
employees %>%
  arrange(department, salary) %>%
  group_by(department) %>%
  slice_head(n = 1) %>%
  ungroup()
```

\newpage

## Question 1.4: Creating New Variables

### k) Salary per year of experience

```{r q1.4k}
employees %>%
  mutate(salary_per_year_exp = salary / years_exp) %>%
  select(name, salary, years_exp, salary_per_year_exp)
```

### l) Performance category

```{r q1.4l}
employees_cat <- employees %>%
  mutate(performance_category = case_when(
    performance_score >= 4.5 ~ "Outstanding",
    performance_score >= 3.5 ~ "Exceeds Expectations",
    performance_score >= 2.5 ~ "Meets Expectations",
    TRUE ~ "Needs Improvement"
  ))

employees_cat %>%
  select(name, performance_score, performance_category)
```

### m) Experience level

```{r q1.4m}
employees_exp <- employees %>%
  mutate(experience_level = case_when(
    years_exp <= 3 ~ "Entry",
    years_exp <= 7 ~ "Mid",
    years_exp <= 12 ~ "Senior",
    TRUE ~ "Expert"
  ))

employees_exp %>%
  select(name, years_exp, experience_level)
```

### n) High performer flag

```{r q1.4n}
employees %>%
  mutate(is_high_performer = performance_score > 4.0 & projects_completed >= 10) %>%
  filter(is_high_performer) %>%
  select(name, department, performance_score, projects_completed)
```

\newpage

## Question 1.5: Aggregation and Grouping

### o) Company-wide summary

```{r q1.5o}
employees %>%
  summarise(
    total_employees = n(),
    avg_salary = mean(salary),
    avg_performance = mean(performance_score),
    total_projects = sum(projects_completed)
  )
```

### p) Summary by department

```{r q1.5p}
employees %>%
  group_by(department) %>%
  summarise(
    count = n(),
    avg_salary = mean(salary),
    avg_perf = mean(performance_score),
    min_exp = min(years_exp),
    max_exp = max(years_exp)
  )
```

### q) Summary by department and role

```{r q1.5q}
dept_role <- employees %>%
  group_by(department, role) %>%
  summarise(avg_salary = mean(salary), count = n(), .groups = "drop") %>%
  arrange(desc(avg_salary))

dept_role

# Highest combo:
dept_role %>% head(1)
```

Managers in the Engineering department have the highest salary on average.

### r) Individual employees' salary as % of department average

```{r q1.5r}
employees %>%
  group_by(department) %>%
  mutate(
    dept_avg = mean(salary),
    pct_of_avg = salary / dept_avg * 100
  ) %>%
  ungroup() %>%
  arrange(desc(pct_of_avg)) %>%
  select(name, department, salary, dept_avg, pct_of_avg)
```

Bella Moore from Finance department earns the most relative to their department's average, with a relative percentage of 156.37%.

### s) Top 3 departments by performance (only considering employees with 3+ years of experience)

```{r q1.5s}
employees %>%
  filter(years_exp >= 3) %>%
  group_by(department) %>%
  summarise(avg_perf = mean(performance_score)) %>%
  arrange(desc(avg_perf)) %>%
  head(3)
```

Only taking into account the work of employees with 3 or more years of experience, the Engineering, Finance, and Sales departments show the best average performance.

\newpage

# Part 2: Social Network Analysis

## Question 2.1: Network Construction and Visualization

### t) Load network data

```{r q2.1t}
library(igraph)
library(RColorBrewer)

email_nodes <- read.csv("data/email_nodes.csv")
email_edges <- read.csv("data/email_edges.csv")

head(email_nodes)
head(email_edges)
```

### u) Construct undirected graph

```{r q2.1u}
email_graph <- graph.data.frame(email_edges, vertices = email_nodes, directed = FALSE)

cat("Nodes:", vcount(email_graph), "\n")
cat("Edges:", ecount(email_graph), "\n")
```

### v) Create plot of network

```{r part_v}
# v) Improved plot

deg <- degree(email_graph)
plot(email_graph, vertex.label = NA, vertex.size = sqrt(deg) * 3,
     edge.width = 0.5, main = "Improved Plot")
```


### w) Department-colored network

```{r q2.1w}
depts <- V(email_graph)$department
unique_depts <- unique(depts)
colors <- brewer.pal(length(unique_depts), "Set1")
names(colors) <- unique_depts

par(mfrow = c(1, 1), mar = c(1, 1, 2, 5))
plot(email_graph, vertex.label = NA, vertex.size = sqrt(deg) * 3,
     vertex.color = colors[depts], edge.width = 0.5,
     main = "Network (colored by Department)")
legend("topright", unique_depts, fill = colors, cex = 0.7, bty = "n")
```

\newpage

## Question 2.2: Connected Components

### x) Find connected components

```{r q2.2x}
comp <- components(email_graph)
cat("Number of components:", comp$no, "\n")
```

### y) Largest component size

```{r q2.2y}
lcc_size <- max(comp$csize)
cat("Largest component:", lcc_size, "employees\n")
cat(round(lcc_size / vcount(email_graph) * 100, 1), "% of employees are in this component\n")
```

### z) Extract and plot largest component

```{r q2.2z}
lcc_id <- which.max(comp$csize)
lcc_nodes <- which(comp$membership == lcc_id)
lcc <- induced_subgraph(email_graph, lcc_nodes)

cat("LCC has", vcount(lcc), "nodes and", ecount(lcc), "edges\n")

deg_lcc <- degree(lcc)
depts_lcc <- V(lcc)$department

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = NA, vertex.size = sqrt(deg_lcc) * 3,
     vertex.color = colors[depts_lcc], edge.width = 0.5,
     main = "Largest Connected Component")
legend("topright", unique_depts, fill = colors, cex = 0.7, bty = "n")
```

### aa) Why use the largest connected component?

To calculate closeness centrality of nodes, every node must be reachable from every other node. If selected nodes are in different components (i.e., graph is disconnected), some distances become infinite and the calculation breaks. Focusing on the largest component helps avoid this problem and gives meaningful values that can be interpreted and compared.

\newpage

## Question 2.3: Centrality Metrics

### bb) Degree Centrality

```{r q2.3bb}
deg_cent <- degree(lcc)
deg_df <- data.frame(id = as.integer(V(lcc)$name), degree = deg_cent) %>%
  left_join(employees %>% select(employee_id, name), by = c("id" = "employee_id")) %>%
  select(id, name, degree) %>%
  arrange(desc(degree))

cat("Top 5 by degree:\n")
head(deg_df, 5)

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = V(lcc)$name, vertex.label.cex = 0.5,
     vertex.size = 2 * sqrt(deg_cent), vertex.color = colors[depts_lcc],
     edge.width = 0.5, main = "Network (sized by Degree)")
legend("topright", unique_depts, fill = colors, cex = 0.6, bty = "n")
```
```{r}

```

### cc) Closeness Centrality

```{r q2.3cc}
close_cent <- closeness(lcc, normalized = TRUE)
close_df <- data.frame(id = as.integer(V(lcc)$name), closeness = close_cent) %>%
  left_join(employees %>% select(employee_id, name), by = c("id" = "employee_id")) %>%
  select(id, name, closeness) %>%
  arrange(desc(closeness))

cat("Top 5 by closeness:\n")
head(close_df, 5)
```

High closeness means the employee can reach other employees quickly (i.e., in shorter distances) - they are central in the network. These employees are effective in spreading information fast since they are "close" to others.

### dd) Betweenness Centrality

```{r q2.3dd}
btw_cent <- betweenness(lcc, normalized = TRUE)
btw_df <- data.frame(id = as.integer(V(lcc)$name), betweenness = btw_cent) %>%
  left_join(employees %>% select(employee_id, name), by = c("id" = "employee_id")) %>%
  select(id, name, betweenness) %>%
  arrange(desc(betweenness))

cat("Top 5 by betweenness:\n")
head(btw_df, 5)
```

Betweenness measures how often an employee sits on the shortest path between other employees. An employee with high betweenness centrality is a bridge or connector. These employees control flow of information - if they do not pass something along properly or get removed, the network will be disrupted and information might not get to where it needs to go.

### ee) PageRank

```{r q2.3ee}
pr <- page_rank(lcc)$vector
pr_df <- data.frame(id = as.integer(V(lcc)$name), pagerank = pr) %>%
  left_join(employees %>% select(employee_id, name), by = c("id" = "employee_id")) %>%
  select(id, name, pagerank) %>%
  arrange(desc(pagerank))

cat("Top 5 by PageRank:\n")
head(pr_df, 5)
```

PageRank is different from simple degree centrality because it takes into account *who* an employee is connected to. Being connected to important employees (i.e., those who are well-connected themselves) boosts an employee's PageRank score more than being connected to isolated employees. It measures an employee's direct and indirect influence instead of simply counting the number of connections.

### ff) Comparing all metrics

```{r q2.3ff}
all_cent <- data.frame(
  id = as.integer(V(lcc)$name),
  degree = deg_cent,
  closeness = close_cent,
  betweenness = btw_cent,
  pagerank = pr
) %>%
  left_join(employees %>% select(employee_id, name, department, role),
            by = c("id" = "employee_id")) %>%
  select(id, name, dept = department, role, degree, closeness, betweenness, pagerank)

top10 <- all_cent %>% arrange(desc(degree)) %>% head(10)
top10

# Rankings
top10 %>%
  mutate(
    deg_r = rank(-degree),
    close_r = rank(-closeness),
    btw_r = rank(-betweenness),
    pr_r = rank(-pagerank)
  ) %>%
  select(id, name, deg_r, close_r, btw_r, pr_r)
```

Employees like Eve Thompson (employee ID: 2) and Bella Moore (employee ID: 28) rank relatively high across board - they are highly influential in the network, connected to many other employees and able to spread information quickly.

Other employees, such as Yuki Tanaka (employee ID: 25) and Nathan Lee (employee ID: 14), have high betweenness but only moderate degree, which suggests that they may not know many other employees but are still central to facilitating communication. There are also employees, such as Wendy Clark (employee ID: 23), who have a high PageRank score but moderate closeness centrality, which implies that while they may not be able to spread information fast, they have influence in the network.

In addition, managers and leads tend to show up more in the dataframe for top 10 employees, which intuitively makes sense given their coordinating role in organizations.

\newpage

## Question 2.4: Community Detection

### gg) Spinglass clustering

```{r q2.4gg}
set.seed(42)
comm <- cluster_spinglass(lcc)

cat("Communities found:", length(comm), "\n")
cat("Modularity:", round(modularity(comm), 3), "\n")
```

### hh) Community sizes

```{r q2.4hh}
mem <- membership(comm)
table(mem)
```

### ii) Visualize by community

```{r q2.4ii}
num_comm <- length(unique(mem))
comm_colors <- brewer.pal(max(3, num_comm), "Set2")

par(mar = c(1, 1, 2, 5))
plot(lcc, vertex.label = V(lcc)$name, vertex.label.cex = 0.5,
     vertex.size = 10, vertex.color = comm_colors[mem],
     edge.width = 0.5, main = "Network (colored by Community)")
legend("topright", paste("Comm", 1:num_comm), fill = comm_colors[1:num_comm],
       cex = 0.6, bty = "n")
```

### jj) Community vs Department

```{r q2.4jj}
comm_dept <- data.frame(
  id = as.integer(V(lcc)$name),
  community = mem,
  department = V(lcc)$department
) %>%
  left_join(employees %>% select(employee_id, name), by = c("id" = "employee_id"))

xtab <- table(comm_dept$community, comm_dept$department)
cat("\nNumber of employees:\n")
xtab

cat("\nPercentages:\n")
round(prop.table(xtab, 1) * 100, 1)
```

The communities match up perfectly with departments, which makes sense given employees are more likely to work with other employees in the same department. However, this also presents a warning in that there may not be much cross-team communication happening, and certain teams could get stuck in their own silos.

### kk) Business insights

Insights the management could take from understanding these communication communities include:

-   The communities go beyond the organizational chart to show how employees actually communicate
-   Employees who bridge multiple communities are valuable, as they help different groups stay connected
-   If a community consists of only one department, it could be a warning sign that the community is working in silo instead of actively connecting with others
-   When planning projects, changes or announcements, it is good practice to work with community leaders to spread the word quickly and effectively

\newpage

# Part 3: Integration and Insights

## Question 3.1: Joining Data

### ll) Join employee data with centrality metrics

```{r q3.1ll}
cent_df <- data.frame(
  employee_id = as.integer(V(lcc)$name),
  degree = degree(lcc),
  closeness = closeness(lcc, normalized = TRUE),
  betweenness = betweenness(lcc, normalized = TRUE),
  pagerank = page_rank(lcc)$vector
)

combined <- employees %>%
  inner_join(cent_df, by = "employee_id")

combined %>%
  select(employee_id, name, department, performance_score,
         degree, closeness, betweenness, pagerank) %>%
  head(10)
```

### mm) Correlation analysis

```{r q3.1mm}
cat("Degree vs Performance:", round(cor(combined$degree, combined$performance_score), 3), "\n")
cat("Closeness vs Performance:", round(cor(combined$closeness, combined$performance_score), 3), "\n")
cat("Betweenness vs Performance:", round(cor(combined$betweenness, combined$performance_score), 3), "\n")
cat("PageRank vs Performance:", round(cor(combined$pagerank, combined$performance_score), 3), "\n")
```

There is a positive relationship between network position and performance, but none of them are very strong. It could be the case that being well-connected helps with performance, or high performers naturally end up being more connected.

### nn) High performers with low centrality

```{r q3.1nn}
med_deg <- median(combined$degree)
cat("Median degree:", med_deg, "\n\n")

combined %>%
  filter(performance_score > 4.0 & degree < med_deg) %>%
  select(employee_id, name, department, role, performance_score, degree, projects_completed) %>%
  arrange(desc(performance_score))
```

While employees like Tara Jenkins (employee ID: 46) do great work, they are flying under the radar network-wise. They may be specialists who do not need to talk to other employees as much, or more introverted. Management should make sure these employees are not getting overlooked for promotions simply because they are not as visible in the network.

\newpage

## Question 3.2: Executive Summary

```{r exec-setup, echo=FALSE}
avg_perf <- round(mean(employees$performance_score), 2)
total_projects <- sum(employees$projects_completed)
high_perf_n <- nrow(employees %>% filter(performance_score > 4.0 & projects_completed >= 10))
lcc_n <- vcount(lcc)

hubs <- combined %>% arrange(desc(betweenness)) %>% head(3)
hub_names <- paste(hubs$name, collapse = ", ")
```

### Executive Summary for TechConnect Management

**Overview**

We have analyzed TechConnect's employee data and email communication patterns to understand performance trends and how information flows through the organization.

**Performance Findings**

The company's average performance score is `r avg_perf` out of 5, which indicates strong performance across the board. Employees have completed `r total_projects` projects in total across all departments. Moreover, we identified `r high_perf_n` employees who are standout performers - scoring above 4.0 and completing 10+ projects each. While there is some variation between departments, overall the workforce is performing well.

**Network Structure**

Looking at email patterns, `r lcc_n` out of 50 employees are in the main communication cluster. The network shows that employees are willing to network beyond their departments - there is a fair amount of cross-team communication. Furthermore, the communities we detected are separated by departments. While this makes sense intuitively, management may want to make additional efforts to encourage cross-department communication.

**Key Employees**

A few employees stand out as communication hubs: `r hub_names`. They have high betweenness centrality, meaning they connect different parts of the organization. If one of them left the company, it could seriously disrupt how information gets around the network.

**Recommendations for TechConnect**

1.  **Use your connectors** - The employees with high betweenness centrality are effective choices for spreading important updates or leading cross-functional projects.

2.  **Watch for silos** - If any department starts communicating only internally, management may want to address it before it snowballs into significant information discrepancies across departments and serious communication issues.

3.  **Do not forget the quiet high performers** - Some of your best people are not super networked, as shown by the case of Tara Jenkins. Make sure they are still getting recognized and considered for advancement, so that they feel appreciated by the company and continue to contribute to the business.

4.  **Plan for departures** - It is good practice to have a backup plan in case a key bridge employee leaves the organization. Examples include cross-training employees or building additional communication paths.

5.  **Think about teams** - When putting together project teams, consider who already talks to whom. Natural communication patterns can make collaboration smoother.
